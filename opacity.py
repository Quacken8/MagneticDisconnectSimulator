#!/usr/bin/env python3
"""
interpolates opacity from a table generated by MESA, in particular the "MESA modules outside MESA" thingy
"""

import numpy as np
import constants as c

pathToOpacityTable = "externalData/kappasFromMESA"

logTs, logRhos, modelKappas = np.loadtxt(pathToOpacityTable, skiprows=1, usecols=(1,2,3)).T

#TODO - maybe unnecessary? maybe working in logs will be better?
# convert to straight variables
modelTs = np.power(10, logTs)
Rhos = np.power(10, logRhos)

# convert to SI from cgs
Rhos *= c.gram/(c.cm**3)
modelKappas  *= c.cm**2/c.gram



modelSPath = "externalData/model_S_new.dat"
modelTs, modelPs, modelKappas = np.loadtxt(modelSPath, skiprows=1, usecols=(1,2,4)).T
# given the structure of the data, it's much better for the nearest interpolation algorithm to work on logs and then exp it later
logmodelTs, logmodelPs, logmodelKappas = np.log(modelTs), np.log(modelPs), np.log(modelKappas)
from scipy.interpolate import NearestNDInterpolator
inteprloatedKappas = NearestNDInterpolator(list(zip(logmodelTs, logmodelPs)), logmodelKappas)

def modelSNearestOpacity(temperature:float|np.ndarray, pressure:float|np.ndarray)->float|np.ndarray:
    """just interpolates using nearest neighbour from the model S kappas"""
    return np.exp(inteprloatedKappas(np.log(temperature), np.log(pressure)))



def main():
    """debugging function for this file"""
    import matplotlib.pyplot as plt

    resolution = 100
    TMesh = np.logspace(np.log10(modelTs[0]), np.log10(modelTs[-1]), num = resolution)
    PMesh = np.logspace(np.log10(modelPs[0]), np.log10(modelPs[-1]), num = resolution)
    TMesh, PMesh = np.meshgrid(TMesh, PMesh)
    kappaMesh = modelSNearestOpacity(TMesh, PMesh)

    
    plt.pcolormesh(TMesh, PMesh, kappaMesh, shading="auto")
    plt.plot(modelTs, modelPs, "ok", label="input point")
    plt.yscale("log")
    plt.xscale("log")
    plt.xlabel("Temperature [K]")
    plt.ylabel("Pressure [Pa]")
    plt.legend()  
    plt.colorbar()
    plt.show()

if __name__ == "__main__":
    main()